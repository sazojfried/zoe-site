<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zoe Friedman — Projects</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Projects page for Zoe Friedman, featuring a Flappy Bird style game."
  />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Press+Start+2P&display=swap"
    rel="stylesheet"
  />

  <style>
    :root {
      --red: #b31b1b;
      --red-soft: #f97373;
      --bg-page: #0b0b10;
      --bg-elevated: #11121a;
      --bg-card: #11121a;
      --border-subtle: #26283a;
      --text-main: #f9fafb;
      --text-muted: #9ca3b4;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.8);

      /* NYC game colors */
      --ground-light: #b31b1b; /* Haverford red */
      --ground-dark: #7f1010;
      --pipe-light: #1e3a8a;   /* gentle dark blue */
      --pipe-dark: #0b1f4f;
    }

    body.theme-dark {
      /* same palette, just slightly deeper */
      --bg-page: #030711;
      --bg-elevated: #050816;
      --bg-card: #050816;
      --border-subtle: #1f2937;
      --text-main: #f9fafb;
      --text-muted: #9ca3b4;
      --shadow-soft: 0 22px 50px rgba(0, 0, 0, 0.9);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      background: var(--bg-page);
      color: var(--text-main);
      transition: background-color 0.25s ease, color 0.25s ease;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    /* NAV */
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: var(--bg-elevated);
      border-bottom: 1px solid var(--border-subtle);
      backdrop-filter: blur(12px);
      transition: background-color 0.25s ease, border-color 0.25s ease;
    }

    .nav-inner {
      max-width: 1040px;
      margin: 0 auto;
      padding: 10px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .logo-block {
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 600;
      line-height: 1.2;
    }

    .logo-name {
      font-size: 18px;
      letter-spacing: 0.18em;
    }

    .logo-sub {
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 400;
    }

    .nav-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .nav-links {
      display: flex;
      gap: 22px;
      font-size: 13px;
      align-items: center;
    }

    .nav-links a {
      padding-bottom: 4px;
      color: var(--text-muted);
      transition: color 0.2s ease;
      position: relative;
    }

    .nav-links a.active,
    .nav-links a:hover {
      color: var(--red-soft);
    }

    .nav-links a.active::after,
    .nav-links a:hover::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 2px;
      background: var(--red-soft);
      border-radius: 999px;
    }

    .theme-toggle {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 5px 10px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease,
        border-color 0.2s ease, transform 0.1s ease;
    }

    .theme-toggle:hover {
      background: rgba(179, 27, 27, 0.08);
      color: var(--text-main);
      border-color: var(--red-soft);
      transform: translateY(-1px);
    }

    .nav-toggle {
      display: none;
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: transparent;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .nav-toggle span {
      display: block;
      width: 16px;
      height: 2px;
      border-radius: 999px;
      background: var(--text-muted);
      transition: transform 0.2s ease, opacity 0.2s ease, background 0.2s ease;
    }

    .nav-toggle span + span {
      margin-top: 3px;
    }

    body.nav-open .nav-toggle span:nth-child(1) {
      transform: translateY(5px) rotate(45deg);
    }

    body.nav-open .nav-toggle span:nth-child(2) {
      opacity: 0;
    }

    body.nav-open .nav-toggle span:nth-child(3) {
      transform: translateY(-5px) rotate(-45deg);
    }

    @media (max-width: 780px) {
      .nav-inner {
        align-items: center;
      }

      .nav-right {
        gap: 8px;
      }

      .nav-links {
        position: absolute;
        left: 0;
        right: 0;
        top: 100%;
        background: var(--bg-elevated);
        border-bottom: 1px solid var(--border-subtle);
        padding: 10px 18px 12px;
        display: none;
        flex-direction: column;
        gap: 10px;
        font-size: 13px;
      }

      body.nav-open .nav-links {
        display: flex;
      }

      .nav-toggle {
        display: inline-flex;
      }
    }

    /* PAGE LAYOUT */
    .page {
      max-width: 1040px;
      margin: 0 auto;
      padding: 24px 18px 40px;
    }

    .card {
      background: var(--bg-card);
      border-radius: 18px;
      padding: 22px 22px 24px;
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
    }

    .section-title {
      margin-bottom: 12px;
    }

    .section-title span {
      font-size: 16px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--red-soft);
      border-bottom: 2px solid var(--red-soft);
      padding-bottom: 3px;
    }

    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .game-container {
      width: 100%;
      max-width: 420px;
      aspect-ratio: 3 / 4;
      border-radius: 18px;
      border: 1px solid var(--border-subtle);
      overflow: hidden;
      background: transparent;
      transform-origin: center;
      transition: transform 0.08s ease-out;
    }

    .game-container.bounce {
      transform: scale(1.03);
    }

    canvas#game-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .game-meta {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    .game-score {
      font-size: 14px;
      font-weight: 600;
      text-align: center;
    }

    .game-instructions {
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
    }

    .difficulty-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .difficulty-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      color: var(--text-muted);
    }

    .difficulty-button {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: transparent;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      color: var(--text-muted);
      transition: background-color 0.15s ease, color 0.15s ease,
        border-color 0.15s ease, transform 0.08s ease;
    }

    .difficulty-button:hover {
      transform: translateY(-1px);
      border-color: var(--red-soft);
    }

    .difficulty-button.active {
      background: var(--red-soft);
      color: #ffffff;
      border-color: var(--red-soft);
    }

    .more-coming {
      margin-top: 28px;
      text-align: center;
      font-size: 14px;
      color: var(--text-muted);
      font-style: italic;
    }

    footer {
      text-align: center;
      padding: 16px;
      font-size: 11px;
      color: var(--text-muted);
      border-top: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      transition: background-color 0.25s ease, border-color 0.25s ease;
    }
  </style>
</head>
<body class="theme-dark">
  <header>
    <div class="nav-inner">
      <div class="logo-block">
        <div class="logo-name">ZOE FRIEDMAN</div>
        <div class="logo-sub">Economics · Softball · Community</div>
      </div>

      <div class="nav-right">
        <nav class="nav-links">
          <a href="index.html#home">Home</a>
          <a href="index.html#stats">Stats</a>
          <a href="index.html#experience">Experience</a>
          <a href="index.html#contact">Contact</a>
          <a href="gallery.html">Gallery</a>
          <a href="projects.html" class="active">Projects</a>
        </nav>

        <button id="theme-toggle" class="theme-toggle" type="button">
          Light mode
        </button>

        <button id="nav-toggle" class="nav-toggle" type="button" aria-label="Toggle navigation">
          <span></span><span></span><span></span>
        </button>
      </div>
    </div>
  </header>

  <main class="page">
    <div class="card">
      <div class="section-title"><span>Flappy Zoe</span></div>

      <div class="game-wrapper">
        <div class="game-container" id="game-container">
          <canvas id="game-canvas"></canvas>
        </div>

        <div class="game-meta">
          <div class="game-score" id="score-display">
            Score: 0&nbsp;|&nbsp;Best: 0
          </div>

          <div class="difficulty-controls">
            <span class="difficulty-label">Difficulty:</span>
            <button class="difficulty-button" data-mode="easy">Easy</button>
            <button class="difficulty-button active" data-mode="normal">Normal</button>
            <button class="difficulty-button" data-mode="cracked">Extremely Difficult</button>
          </div>

          <div class="game-instructions">
            Click / tap / press space or ↑ to flap.
          </div>
        </div>
      </div>
    </div>
        <div class="card">
      <div class="section-title"><span>Dad Invaders</span></div>

      <div class="game-wrapper">
        <div class="game-container" id="dad-container">
          <canvas id="dad-canvas"></canvas>
        </div>

        <div class="game-meta">
          <div class="game-score" id="dad-score-display">
            Score: 0000&nbsp;|&nbsp;High: 0000&nbsp;|&nbsp;Wave: 1&nbsp;|&nbsp;Lives: 3
          </div>

          <div class="game-instructions">
            MOVE: ← → &nbsp;&nbsp;|&nbsp;&nbsp; SHOOT: SPACE / ↑ &nbsp;&nbsp;|&nbsp;&nbsp; PAUSE: P
          </div>
        </div>
      </div>
      <div class="more-coming">More projects coming soon...</div>
    </div>

  </main>

  <footer>
    © <span id="year"></span> Zoe Friedman. All rights reserved.
  </footer>

  <script>
    // Footer year
    document.getElementById("year").textContent = new Date().getFullYear();

    const body = document.body;
    const themeToggle = document.getElementById("theme-toggle");
    const navToggle = document.getElementById("nav-toggle");

    function updateThemeLabel() {
      themeToggle.textContent = body.classList.contains("theme-dark")
        ? "Light mode"
        : "Dark mode";
    }

    themeToggle.addEventListener("click", () => {
      body.classList.toggle("theme-dark");
      updateThemeLabel();
    });
    updateThemeLabel();

    navToggle.addEventListener("click", () => {
      body.classList.toggle("nav-open");
    });

    document.querySelectorAll(".nav-links a").forEach((link) => {
      link.addEventListener("click", () => {
        body.classList.remove("nav-open");
      });
    });

    // --------- Flappy Zoe Game ----------
    (function () {
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const scoreDisplay = document.getElementById("score-display");
      const gameContainer = document.getElementById("game-container");

      const WIDTH = 360;
      const HEIGHT = 480;
      canvas.width = WIDTH;
      canvas.height = HEIGHT;

      // Zoe's face
      const birdImg = new Image();
      birdImg.src = "images/z1.png";
      let birdImgLoaded = false;
      birdImg.onload = () => (birdImgLoaded = true);

      // Bird (separate visual radius + hitbox)
      let birdDrawRadius = 28;   // how big Zoe LOOKS
      let birdHitRadius  = 20;   // how big Zoe PLAYS
      let birdX = WIDTH / 2;
      let birdY = HEIGHT / 2;
      let birdVel = 0;
      let birdScale = 1;

      // Difficulties
      const difficulties = {
        easy:   { gap: 150, baseSpeed: 1.7, gravity: 0.30, flap: -6.8 },
        normal: { gap: 125, baseSpeed: 2.0, gravity: 0.35, flap: -6.2 },
        cracked:{ gap: 100, baseSpeed: 2.4, gravity: 0.40, flap: -5.6 }
      };

      let currentMode = "normal";
      let pipeGap = difficulties[currentMode].gap;
      let baseSpeed = difficulties[currentMode].baseSpeed;
      let gravity = difficulties[currentMode].gravity;
      let flapStrength = difficulties[currentMode].flap;
      const maxExtraSpeed = 1.2;

      // Pipes
      const pipeWidth = 55;
      let pipes = [];
      let frame = 0;

      // Skyline + ground scroll (smooth tiling)
      let skylineFarOffset = 0;
      let skylineNearOffset = 0;
      let groundOffset = 0;

      // Score / state
      let score = 0;
      let best = 0;
      let started = false;
      let gameOver = false;
      let gotNewBestThisRun = false;

      // Easter egg party state (extremely difficult mode, score 14)
      const PARTY_TRIGGER_SCORE = 14;
      let partyActive = false;
      let partyFrame = 0;
      let partyCountdown = 3;

      // Confetti only for new high score at end + party event
      let confettiTimer = 0;
      const confettiColors = ["#f97373", "#22c55e", "#3b82f6", "#facc15", "#e879f9"];

      // Audio (simple beeps)
      let audioCtx = null;
      function playTone(freq, duration, type, volume) {
        try {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type || "sine";
          osc.frequency.value = freq;
          gain.gain.value = volume;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + duration);
        } catch (e) {
          // ignore if unavailable
        }
      }

      function playFlapSound() {
        playTone(650, 0.08, "triangle", 0.08);
      }

      function playScoreSound() {
        playTone(900, 0.12, "square", 0.09);
      }

      function playHitSound() {
        playTone(180, 0.22, "sawtooth", 0.12);
      }

      function updateScoreDisplay() {
        scoreDisplay.textContent = "Score: " + score + " \u00a0|\u00a0 Best: " + best;
      }

      function currentSpeed() {
        return baseSpeed + Math.min(score * 0.08, maxExtraSpeed);
      }

      function applyDifficulty(mode) {
        currentMode = mode;
        const d = difficulties[mode];
        pipeGap = d.gap;
        baseSpeed = d.baseSpeed;
        gravity = d.gravity;
        flapStrength = d.flap;

        document.querySelectorAll(".difficulty-button").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.mode === mode);
        });

        resetGame();
      }

      document.querySelectorAll(".difficulty-button").forEach((btn) => {
        btn.addEventListener("click", () => {
          applyDifficulty(btn.dataset.mode);
        });
      });

      function resetGame() {
        birdY = HEIGHT / 2;
        birdVel = 0;
        birdScale = 1;
        pipes = [];
        frame = 0;
        score = 0;
        started = false;
        gameOver = false;
        gotNewBestThisRun = false;

        skylineFarOffset = 0;
        skylineNearOffset = 0;
        groundOffset = 0;

        confettiTimer = 0;

        partyActive = false;
        partyFrame = 0;
        partyCountdown = 3;

        updateScoreDisplay();
      }

      function spawnPipe() {
        const minTop = 40;
        const maxTop = HEIGHT - pipeGap - 80;
        const top = minTop + Math.random() * (maxTop - minTop);
        pipes.push({
          x: WIDTH + pipeWidth,
          top,
          passed: false
        });
      }

      function flap() {
        if (!started) started = true;
        if (gameOver) {
          resetGame();
          return;
        }
        if (partyActive) {
          // ignore flaps during party countdown
          return;
        }
        birdVel = flapStrength;
        birdScale = 1.12;
        gameContainer.classList.add("bounce");
        setTimeout(() => gameContainer.classList.remove("bounce"), 90);
        playFlapSound();
      }

      // Input
      canvas.addEventListener("click", flap);
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        flap();
      }, { passive: false });

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          flap();
        }
      });

      function triggerParty() {
        partyActive = true;
        partyFrame = 0;
        partyCountdown = 3;
        confettiTimer = 160; // extra confetti burst
      }

      function drawNYCSkylineBackground() {
        // sunset gradient
        const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        grad.addColorStop(0, "#ffb347"); // top orange
        grad.addColorStop(0.4, "#ff5f6d"); // pink
        grad.addColorStop(1, "#1f2937");   // deep blue
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // --- FAR SKYLINE (slow layer, seamless loop) ---
        const farTile = 70;
        skylineFarOffset -= currentSpeed() * 0.25;
        if (skylineFarOffset <= -farTile) skylineFarOffset += farTile;

        ctx.fillStyle = "rgba(15,23,42,0.9)";
        for (let i = 0, x = skylineFarOffset; x < WIDTH + farTile; i++, x += farTile) {
          const h = 80 + ((i * 37) % 40) + 40;
          const y = HEIGHT - 80 - h;
          const w = 40;
          ctx.fillRect(x, y, w, h);

          if (i % 3 === 0) {
            ctx.fillRect(x + w * 0.45, y - 20, w * 0.1, 20);
          }
        }

        // --- NEAR SKYLINE (faster parallax, also tiled) ---
        const nearTile = 90;
        skylineNearOffset -= currentSpeed() * 0.4;
        if (skylineNearOffset <= -nearTile) skylineNearOffset += nearTile;

        ctx.fillStyle = "rgba(10,16,32,1)";
        for (let i = 0, x = skylineNearOffset; x < WIDTH + nearTile; i++, x += nearTile) {
          const h = 60 + ((i * 53) % 50) + 40;
          const y = HEIGHT - 60 - h;
          const w = 46;
          ctx.fillRect(x, y, w, h);
        }

        // --- GROUND (Haverford red) ---
        const groundLight = getComputedStyle(document.documentElement)
          .getPropertyValue("--ground-light").trim();
        const groundDark = getComputedStyle(document.documentElement)
          .getPropertyValue("--ground-dark").trim();

        groundOffset -= currentSpeed() * 0.5;
        if (groundOffset <= -WIDTH) groundOffset += WIDTH;

        const groundH = 34;
        const bottomY = HEIGHT - groundH;
        const groundGrad = ctx.createLinearGradient(0, bottomY, 0, HEIGHT);
        groundGrad.addColorStop(0, groundLight);
        groundGrad.addColorStop(1, groundDark);
        ctx.fillStyle = groundGrad;
        ctx.fillRect(groundOffset, bottomY, WIDTH, groundH);
        ctx.fillRect(groundOffset + WIDTH, bottomY, WIDTH, groundH);
      }

      function drawPipes() {
        const pipeLight = getComputedStyle(document.documentElement)
          .getPropertyValue("--pipe-light").trim();
        const pipeDark = getComputedStyle(document.documentElement)
          .getPropertyValue("--pipe-dark").trim();

        for (const p of pipes) {
          const x = p.x;

          // top pipe
          ctx.fillStyle = pipeLight;
          ctx.fillRect(x, 0, pipeWidth, p.top);
          ctx.fillStyle = pipeDark;
          ctx.fillRect(x, p.top - 18, pipeWidth, 18);

          // bottom pipe
          ctx.fillStyle = pipeLight;
          ctx.fillRect(x, p.top + pipeGap, pipeWidth, HEIGHT - (p.top + pipeGap));
          ctx.fillStyle = pipeDark;
          ctx.fillRect(x, p.top + pipeGap, pipeWidth, 18);
        }
      }

      // soft shadow under Zoe
      function drawBirdShadow() {
        const groundY = HEIGHT - 34; // same as ground height in background
        const maxShadowY = groundY - 2;
        const shadowY = Math.min(birdY + birdDrawRadius + 10, maxShadowY);
        const shadowX = birdX;

        const distToGround = Math.max(0, groundY - birdY - birdDrawRadius);
        const t = Math.max(0, Math.min(1, distToGround / 120)); // 0 when close to ground
        const maxRadiusX = birdDrawRadius * 1.0;
        const minRadiusX = birdDrawRadius * 0.4;
        const radiusX = minRadiusX + (maxRadiusX - minRadiusX) * t;
        const radiusY = 5 + 5 * t;

        ctx.save();
        ctx.translate(shadowX, shadowY);
        ctx.beginPath();
        ctx.scale(1, radiusY / radiusX);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.arc(0, 0, radiusX, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawBird() {
        ctx.save();
        ctx.translate(birdX, birdY);
        const tilt = Math.max(-0.5, Math.min(0.5, birdVel / 9));
        ctx.rotate(tilt);

        birdScale += (1 - birdScale) * 0.12;
        ctx.scale(birdScale, birdScale);

        if (birdImgLoaded) {
          ctx.beginPath();
          ctx.arc(0, 0, birdDrawRadius, 0, Math.PI * 2);
          ctx.clip();
          ctx.drawImage(
            birdImg,
            -birdDrawRadius,
            -birdDrawRadius,
            birdDrawRadius * 2,
            birdDrawRadius * 2
          );
        } else {
          ctx.fillStyle = "#b31b1b";
          ctx.beginPath();
          ctx.arc(0, 0, birdDrawRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawConfetti() {
        if (confettiTimer <= 0) return;
        for (let i = 0; i < 45; i++) {
          const x = Math.random() * WIDTH;
          const y = Math.random() * (HEIGHT * 0.6);
          const w = 3;
          const h = 7 + Math.random() * 4;
          ctx.fillStyle =
            confettiColors[Math.floor(Math.random() * confettiColors.length)];
          ctx.fillRect(x, y, w, h);
        }
        confettiTimer--;
      }

      function update() {
        if (!started) {
          draw();
          requestAnimationFrame(update);
          return;
        }

        // Party easter egg: pause physics, show countdown, keep rendering
        if (partyActive) {
          partyFrame++;

          if (partyFrame === 90) partyCountdown = 2;
          else if (partyFrame === 180) partyCountdown = 1;
          else if (partyFrame === 240) {
            partyCountdown = 0;
            partyActive = false; // resume game
          }

          draw();
          requestAnimationFrame(update);
          return;
        }

        if (!gameOver) {
          frame++;

          birdVel += gravity;
          birdY += birdVel;

          if (frame % 110 === 0) spawnPipe();

          const speed = currentSpeed();
          for (const p of pipes) {
            p.x -= speed;
          }
          pipes = pipes.filter((p) => p.x + pipeWidth > 0);

          // bounds collisions (with hitbox radius)
          if (!gameOver && (birdY + birdHitRadius >= HEIGHT || birdY - birdHitRadius <= 0)) {
            gameOver = true;
            playHitSound();
            if (gotNewBestThisRun) confettiTimer = 120;
          }

          // pipe collisions + scoring
          for (const p of pipes) {
            const inX =
              birdX + birdHitRadius > p.x &&
              birdX - birdHitRadius < p.x + pipeWidth;
            const hitTop = birdY - birdHitRadius < p.top;
            const hitBottom = birdY + birdHitRadius > p.top + pipeGap;

            if (!gameOver && inX && (hitTop || hitBottom)) {
              gameOver = true;
              playHitSound();
              if (gotNewBestThisRun) confettiTimer = 120;
            }

            if (!p.passed && p.x + pipeWidth < birdX - birdHitRadius) {
              p.passed = true;
              score++;
              if (score > best) {
                best = score;
                gotNewBestThisRun = true;
              }

              // Easter egg: party at score 14 in Extremely Difficult mode
              if (
                currentMode === "cracked" &&
                score === PARTY_TRIGGER_SCORE &&
                !partyActive &&
                !gameOver
              ) {
                triggerParty();
              }

              playScoreSound();
              updateScoreDisplay();
            }
          }
        }

        draw();
        requestAnimationFrame(update);
      }

      function draw() {
        drawNYCSkylineBackground();
        drawPipes();
        drawBirdShadow();
        drawBird();
        drawConfetti();

        ctx.textAlign = "center";

        if (!started && !gameOver) {
          ctx.font = '12px "Press Start 2P", system-ui, monospace';
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "rgba(0,0,0,0.7)";
          ctx.lineWidth = 3;
          ctx.strokeText("CLICK / TAP / SPACE TO START", WIDTH / 2, HEIGHT / 2 - 60);
          ctx.fillText("CLICK / TAP / SPACE TO START", WIDTH / 2, HEIGHT / 2 - 60);
        } else if (partyActive) {
          ctx.font = '16px "Press Start 2P", system-ui, monospace';
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "rgba(0,0,0,0.9)";
          ctx.lineWidth = 4;
          ctx.strokeText("PARTYYYY!!!", WIDTH / 2, HEIGHT / 2 - 40);
          ctx.fillText("PARTYYYY!!!", WIDTH / 2, HEIGHT / 2 - 40);

          ctx.font = '10px "Press Start 2P", system-ui, monospace';
          ctx.strokeText("SCORE 14 ON EXTREME", WIDTH / 2, HEIGHT / 2 - 10);
          ctx.fillText("SCORE 14 ON EXTREME", WIDTH / 2, HEIGHT / 2 - 10);

          if (partyCountdown > 0) {
            ctx.font = '12px "Press Start 2P", system-ui, monospace';
            const text = "RESUMING IN " + partyCountdown;
            ctx.strokeText(text, WIDTH / 2, HEIGHT / 2 + 30);
            ctx.fillText(text, WIDTH / 2, HEIGHT / 2 + 30);
          }
        } else if (gameOver) {
          // main GAME OVER text
          ctx.font = '18px "Press Start 2P", system-ui, monospace';
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "rgba(0,0,0,0.8)";
          ctx.lineWidth = 4;
          ctx.strokeText("GAME OVER", WIDTH / 2, HEIGHT / 2 - 10);
          ctx.fillText("GAME OVER", WIDTH / 2, HEIGHT / 2 - 10);

          // restart instructions
          ctx.font = '10px "Press Start 2P", system-ui, monospace';
          ctx.strokeText("CLICK / TAP / SPACE TO RESTART", WIDTH / 2, HEIGHT / 2 + 20);
          ctx.fillText("CLICK / TAP / SPACE TO RESTART", WIDTH / 2, HEIGHT / 2 + 20);

          // new high score banner
          if (gotNewBestThisRun) {
            ctx.font = '12px "Press Start 2P", system-ui, monospace';
            ctx.strokeText("NEW HIGH SCORE!", WIDTH / 2, HEIGHT / 2 - 40);
            ctx.fillText("NEW HIGH SCORE!", WIDTH / 2, HEIGHT / 2 - 40);
          }
        }
      }

      // init
      updateScoreDisplay();
      applyDifficulty("normal"); // sets mode & resets
      update();
    })();

          // --------- Dad Invaders Game (easier + dad1.png) ----------
    (function () {
      const canvas = document.getElementById("dad-canvas");
      const ctx = canvas.getContext("2d");
      if (!canvas || !ctx) return;

      const scoreEl = document.getElementById("dad-score-display");
      const container = document.getElementById("dad-container");

      const WIDTH = 360;
      const HEIGHT = 420;
      canvas.width = WIDTH;
      canvas.height = HEIGHT;

      const PIXEL_FONT = '"Press Start 2P", system-ui, monospace';

      // --- Player (Dad ship) ---
      const playerImg = new Image();
      playerImg.src = "images/dad1.png";  // make sure this EXACT path/name exists
      let playerImgLoaded = false;
      playerImg.onload = () => {
        playerImgLoaded = true;
        console.log("Dad sprite loaded from images/dad1.png");
      };
      playerImg.onerror = () => {
        console.error("Could not load images/dad1.png — check file name/path (case-sensitive).");
      };

      const player = {
        w: 40,    // slightly bigger so the PNG is more visible
        h: 26,
        x: WIDTH / 2 - 20,
        y: HEIGHT - 52,
        speed: 2.7,  // a bit faster for easier dodging
        movingLeft: false,
        movingRight: false,
        lastShot: 0,
        shotCooldown: 280 // can shoot a bit more often
      };

      // --- Game state ---
      let started = false;
      let paused = false;
      let gameOver = false;

      let score = 0;
      let highScore = parseInt(
        localStorage.getItem("DadInvadersHighScore") || "0",
        10
      );
      let wave = 1;
      let lives = 5;  // give Dad more lives

      // --- Invaders (easier baseline) ---
      let invaders = [];
      let invaderDir = 1;
      let invaderSpeedBase = 0.30;  // was 0.45, now slower
      let invaderSpeed = invaderSpeedBase;
      const invaderStepDown = 10;
      const rows = 5;
      const cols = 10;
      const invaderW = 18;
      const invaderH = 14;
      const invaderStartX = 26;
      const invaderStartY = 60;
      const invaderGapX = 26;
      const invaderGapY = 22;

      let invadersAlive = 0;

      // --- Bullets ---
      const playerBullets = [];
      const invaderBullets = [];
      const maxPlayerBullets = 1;  // keep classic one-shot rule
      const maxInvaderBullets = 5; // cap enemy spam

      // --- Shields ---
      const shields = [];
      const shieldWidth = 40;
      const shieldHeight = 24;
      const shieldBlock = 4;

      // --- UFO ---
      let ufo = null; // {x,y,w,h,speed}

      // --- Input ---
      const keys = {};

      function updateScoreDisplay() {
        const s = score.toString().padStart(4, "0");
        const h = highScore.toString().padStart(4, "0");
        scoreEl.innerHTML =
          "Score: " + s +
          "&nbsp;|&nbsp;High: " + h +
          "&nbsp;|&nbsp;Wave: " + wave +
          "&nbsp;|&nbsp;Lives: " + lives;
      }

      function resetInvaders() {
        invaders = [];
        invadersAlive = 0;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = invaderStartX + c * invaderGapX;
            const y = invaderStartY + r * invaderGapY;
            invaders.push({
              x,
              y,
              w: invaderW,
              h: invaderH,
              alive: true,
              type: r
            });
            invadersAlive++;
          }
        }
        invaderDir = 1;
        // wave speed-up, but gentler
        invaderSpeedBase *= 1 + (wave - 1) * 0.05;
        invaderSpeed = invaderSpeedBase;
      }

      function resetShields() {
        shields.length = 0;
        const shieldCount = 3;
        const spacing = WIDTH / (shieldCount + 1);
        for (let i = 0; i < shieldCount; i++) {
          const centerX = spacing * (i + 1);
          const startX = centerX - shieldWidth / 2;
          const startY = HEIGHT - 120;
          for (let y = 0; y < shieldHeight; y += shieldBlock) {
            for (let x = 0; x < shieldWidth; x += shieldBlock) {
              const relX = x / shieldBlock;
              const relY = y / shieldBlock;
              if (
                relY > 3 &&
                (relX === 1 || relX === 2 || relX === 7 || relX === 8)
              ) {
                continue;
              }
              shields.push({
                x: startX + x,
                y: startY + y,
                w: shieldBlock,
                h: shieldBlock,
                alive: true
              });
            }
          }
        }
      }

      function spawnUFO() {
        const chance = 0.0015; // a bit rarer
        if (ufo || !started || gameOver) return;
        if (Math.random() < chance) {
          const dir = Math.random() < 0.5 ? 1 : -1;
          const w = 36;
          const h = 16;
          const y = 32;
          const x = dir === 1 ? -w - 5 : WIDTH + 5;
          ufo = {
            x,
            y,
            w,
            h,
            speed: 1.3 * dir
          };
        }
      }

      function explodeUFO() {
        if (!ufo) return;
        const bonusChoices = [50, 100, 150, 300];
        const bonus =
          bonusChoices[Math.floor(Math.random() * bonusChoices.length)];
        score += bonus;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("DadInvadersHighScore", String(highScore));
        }
        ufo = null;
      }

      function resetGame(fullReset = false) {
        if (fullReset) {
          score = 0;
          wave = 1;
          lives = 5;
          invaderSpeedBase = 0.30;
        }
        started = false;
        paused = false;
        gameOver = false;
        player.x = WIDTH / 2 - player.w / 2;
        playerBullets.length = 0;
        invaderBullets.length = 0;
        ufo = null;
        resetInvaders();
        resetShields();
        updateScoreDisplay();
      }

      function rectsCollide(a, b) {
        return !(
          a.x + a.w < b.x ||
          a.x > b.x + b.w ||
          a.y + a.h < b.y ||
          a.y > b.y + b.h
        );
      }

      function shootPlayerBullet() {
        const now = performance.now();
        if (playerBullets.length >= maxPlayerBullets) return;
        if (now - player.lastShot < player.shotCooldown) return;
        playerBullets.push({
          x: player.x + player.w / 2 - 1,
          y: player.y - 6,
          w: 2,
          h: 8,
          vy: -3.9
        });
        player.lastShot = now;
      }

      function invadersCanFire(inv) {
        for (let other of invaders) {
          if (
            other.alive &&
            other !== inv &&
            Math.abs(other.x - inv.x) < 2 &&
            other.y > inv.y
          ) {
            return false;
          }
        }
        return true;
      }

      function maybeInvaderShoot() {
        if (invaderBullets.length >= maxInvaderBullets) return;
        const fireChanceBase = 0.0015;   // was 0.0025
        const fireWaveFactor = 0.0002;   // slightly smaller scaling
        const fireChance = fireChanceBase + fireWaveFactor * wave;

        for (let inv of invaders) {
          if (!inv.alive) continue;
          if (!invadersCanFire(inv)) continue;
          if (Math.random() < fireChance) {
            invaderBullets.push({
              x: inv.x + inv.w / 2 - 1,
              y: inv.y + inv.h,
              w: 2,
              h: 8,
              vy: 1.7 + 0.12 * wave  // slower bullets
            });
          }
        }
      }

      function updateInvaders() {
        let leftMost = Infinity;
        let rightMost = -Infinity;
        let bottomMost = -Infinity;

        for (let inv of invaders) {
          if (!inv.alive) continue;
          if (inv.x < leftMost) leftMost = inv.x;
          if (inv.x + inv.w > rightMost) rightMost = inv.x + inv.w;
          if (inv.y + inv.h > bottomMost) bottomMost = inv.y + inv.h;
        }

        if (invadersAlive === 0) {
          wave++;
          resetInvaders();
          resetShields();
          return;
        }

        const total = rows * cols;
        const ratio = 1 - invadersAlive / total;
        invaderSpeed = invaderSpeedBase * (1 + ratio * 2.4); // still speeds up, but gentler than *3

        if (leftMost <= 10 && invaderDir < 0) {
          invaderDir = 1;
          for (let inv of invaders) if (inv.alive) inv.y += invaderStepDown;
        } else if (rightMost >= WIDTH - 10 && invaderDir > 0) {
          invaderDir = -1;
          for (let inv of invaders) if (inv.alive) inv.y += invaderStepDown;
        }

        for (let inv of invaders) {
          if (!inv.alive) continue;
          inv.x += invaderDir * invaderSpeed;
        }

        if (bottomMost >= HEIGHT - 80) {
          loseLife();
        }
      }

      function loseLife() {
        lives--;
        if (lives <= 0) {
          gameOver = true;
        } else {
          player.x = WIDTH / 2 - player.w / 2;
          playerBullets.length = 0;
          invaderBullets.length = 0;
          resetInvaders();
        }
        updateScoreDisplay();
      }

      function updateBullets() {
        for (let b of playerBullets) {
          b.y += b.vy;
        }
        for (let i = playerBullets.length - 1; i >= 0; i--) {
          if (playerBullets[i].y + playerBullets[i].h < 0) {
            playerBullets.splice(i, 1);
          }
        }

        for (let b of invaderBullets) {
          b.y += b.vy;
        }
        for (let i = invaderBullets.length - 1; i >= 0; i--) {
          if (invaderBullets[i].y > HEIGHT) {
            invaderBullets.splice(i, 1);
          }
        }
      }

      function handleCollisions() {
        // Player bullets
        for (let i = playerBullets.length - 1; i >= 0; i--) {
          const b = playerBullets[i];
          const bRect = { x: b.x, y: b.y, w: b.w, h: b.h };

          // vs UFO
          if (ufo) {
            const uRect = { x: ufo.x, y: ufo.y, w: ufo.w, h: ufo.h };
            if (rectsCollide(bRect, uRect)) {
              explodeUFO();
              playerBullets.splice(i, 1);
              continue;
            }
          }

          // vs invaders
          let hitInvader = false;
          for (let inv of invaders) {
            if (!inv.alive) continue;
            const iRect = { x: inv.x, y: inv.y, w: inv.w, h: inv.h };
            if (rectsCollide(bRect, iRect)) {
              inv.alive = false;
              invadersAlive--;
              hitInvader = true;
              const baseScore = 10 + (rows - inv.type - 1) * 10;
              score += baseScore;
              if (score > highScore) {
                highScore = score;
                localStorage.setItem("DadInvadersHighScore", String(highScore));
              }
              break;
            }
          }
          if (hitInvader) {
            playerBullets.splice(i, 1);
            continue;
          }

          // vs shields
          for (let s of shields) {
            if (!s.alive) continue;
            const sRect = { x: s.x, y: s.y, w: s.w, h: s.h };
            if (rectsCollide(bRect, sRect)) {
              s.alive = false;
              playerBullets.splice(i, 1);
              break;
            }
          }
        }

        // Invader bullets
        for (let i = invaderBullets.length - 1; i >= 0; i--) {
          const b = invaderBullets[i];
          const bRect = { x: b.x, y: b.y, w: b.w, h: b.h };

          // vs shields
          let destroyed = false;
          for (let s of shields) {
            if (!s.alive) continue;
            const sRect = { x: s.x, y: s.y, w: s.w, h: s.h };
            if (rectsCollide(bRect, sRect)) {
              s.alive = false;
              invaderBullets.splice(i, 1);
              destroyed = true;
              break;
            }
          }
          if (destroyed) continue;

          // vs player
          const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
          if (rectsCollide(bRect, pRect)) {
            invaderBullets.splice(i, 1);
            loseLife();
            break;
          }
        }
      }

      function updateUFO() {
        if (!ufo) return;
        ufo.x += ufo.speed;
        if (ufo.speed > 0 && ufo.x > WIDTH + 40) {
          ufo = null;
        } else if (ufo.speed < 0 && ufo.x < -40) {
          ufo = null;
        }
      }

      function updatePlayer() {
        if (player.movingLeft) {
          player.x -= player.speed;
        } else if (player.movingRight) {
          player.x += player.speed;
        }
        if (player.x < 8) player.x = 8;
        if (player.x + player.w > WIDTH - 8) player.x = WIDTH - 8 - player.w;
      }

      // --- Drawing ---
      function drawBackground() {
        const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        g.addColorStop(0, "#020617");
        g.addColorStop(1, "#000000");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        ctx.fillStyle = "rgba(148, 163, 184, 0.9)";
        for (let i = 0; i < 40; i++) {
          const x = (i * 59) % WIDTH;
          const y = (i * 101) % HEIGHT;
          const r = (i % 3 === 0) ? 1.3 : 0.8;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawPlayer() {
        if (playerImgLoaded) {
          ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
        } else {
          ctx.fillStyle = "#f97373";
          ctx.fillRect(player.x, player.y, player.w, player.h);
        }
      }

      function drawInvaders() {
        ctx.fillStyle = "#22c55e";
        for (let inv of invaders) {
          if (!inv.alive) continue;
          ctx.fillRect(inv.x, inv.y, inv.w, inv.h);
        }
      }

      function drawShields() {
        for (let s of shields) {
          if (!s.alive) continue;
          ctx.fillStyle = "#e5e7eb";
          ctx.fillRect(s.x, s.y, s.w, s.h);
        }
      }

      function drawBullets() {
        ctx.fillStyle = "#facc15";
        for (let b of playerBullets) {
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }
        ctx.fillStyle = "#38bdf8";
        for (let b of invaderBullets) {
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }
      }

      function drawUFO() {
        if (!ufo) return;
        ctx.fillStyle = "#f97373";
        ctx.fillRect(ufo.x, ufo.y, ufo.w, ufo.h);
        ctx.fillStyle = "#fed7aa";
        ctx.fillRect(ufo.x + 4, ufo.y + 4, ufo.w - 8, ufo.h - 8);
      }

      function drawOverlayText(main, sub) {
        ctx.textAlign = "center";

        if (main) {
          ctx.font = '16px ' + PIXEL_FONT;
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "rgba(0,0,0,0.8)";
          ctx.lineWidth = 4;
          ctx.strokeText(main, WIDTH / 2, HEIGHT / 2 - 18);
          ctx.fillText(main, WIDTH / 2, HEIGHT / 2 - 18);
        }

        if (sub) {
          ctx.font = '9px ' + PIXEL_FONT;
          ctx.strokeText(sub, WIDTH / 2, HEIGHT / 2 + 10);
          ctx.fillText(sub, WIDTH / 2, HEIGHT / 2 + 10);
        }
      }

      function loop() {
        if (!canvas.isConnected) return;

        drawBackground();
        drawShields();
        drawInvaders();
        drawBullets();
        drawUFO();
        drawPlayer();

        if (!started) {
          drawOverlayText("DAD INVADERS", "PRESS SPACE TO START");
        } else if (paused) {
          drawOverlayText("PAUSED", "PRESS P TO RESUME");
        } else if (gameOver) {
          drawOverlayText("GAME OVER", "SPACE TO PLAY AGAIN");
        }

        requestAnimationFrame(loop);
      }

      function tick() {
        if (!started || paused || gameOver) {
          requestAnimationFrame(tick);
          return;
        }

        updatePlayer();
        updateInvaders();
        updateBullets();
        updateUFO();
        maybeInvaderShoot();
        handleCollisions();
        spawnUFO();
        updateScoreDisplay();

        requestAnimationFrame(tick);
      }

      // --- Input ---
      window.addEventListener("keydown", (e) => {
        if (e.code === "ArrowLeft" || e.code === "KeyA") {
          player.movingLeft = true;
        } else if (e.code === "ArrowRight" || e.code === "KeyD") {
          player.movingRight = true;
        } else if (e.code === "Space" || e.code === "ArrowUp") {
          if (!started) {
            started = true;
            paused = false;
            gameOver = false;
          } else if (gameOver) {
            resetGame(true);
            started = true;
          } else {
            shootPlayerBullet();
          }
        } else if (e.code === "KeyP") {
          if (started && !gameOver) {
            paused = !paused;
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code === "ArrowLeft" || e.code === "KeyA") {
          player.movingLeft = false;
        } else if (e.code === "ArrowRight" || e.code === "KeyD") {
          player.movingRight = false;
        }
      });

      canvas.addEventListener("click", () => {
        if (!started) {
          started = true;
          paused = false;
          gameOver = false;
        } else if (gameOver) {
          resetGame(true);
          started = true;
        } else {
          shootPlayerBullet();
        }
      });

      // Init
      resetGame(true);
      loop();
      tick();
    })();
  </script>
</body>
</html>
